#+AUTHOR: Ryan Sharif
#+TITLE: Homework 6: Containerization support languages
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{emacs}
#+LATEX_HEADER: \usepackage{amsthm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{mathpazo}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \linespread{1.05}
#+LaTex_HEADER: \usepackage{usenix,epsfig,endnotes}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usetikzlibrary{positioning,calc}
#+LATEX_HEADER: \usepackage{url}
#+OPTIONS: toc:nil
#+LaTeX_CLASS_OPTIONS: [letterpaper,twocolumn,10pt]
#+BIBLIOGRAPHY: refs acm

# Abstract

# Linux Containers (LXC)
* Containers
** Linux containers (LXC)
   For several  decades, the model  of running software on  a computer
   consisted of a hardware layer  and an operating system layer, which
   created an environment  for running and executing  a user's machine
   code. Although the virtual machine  model traces its history to the
   early 1960s  \cite{pugh:1995}, virtualization of a  hardware system
   became popular in the late 1990s through software such as VMware.
   
   Initially  released in  2008 \cite{linuxlxc2016},  Linux containers
   (LXC) have become a popular  approach to virtualization. LXC are an
   alternative to  the virtual  machine approaches, which  emulate the
   hardware of a computer system  through software, e.g., CPU, memory,
   and hard-disks.  LXC, on the other hand, run using a system's Linux
   kernel, which isolates and manages the resources of an application,
   allowing a container full  access to CPU, memory, input-and-output,
   etc...
   
   Put simply, an  LXC is the marriage between  executing machine code
   natively and executing  machine code on a virtual  machine, you get
   the  benefits  and  isolation  of a  virtual  machine  without  the
   overhead memory and CPU costs.  In other words, a container affords
   developers  the  benefits  of  virtualization  without  a  hardware
   emulation layer. Thus, our analysis of containers will proceed with
   these core ideas.

** Docker containers
   # fix, this should include information about the recent switch
   # from LXC to runc
   # http://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine
   According   to  their   documentation  \cite{docker:2016},   Docker
   containers  ship  a  piece  of  software  with  a  filesystem  with
   everything needed to  run code, runtimes, system  tools, and system
   libraries,  i.e., a  useable virtual  machine.  The  project is  an
   open-source approach to LXC, with the ability to track changes to a
   system in a way that is analagous to source code management systems
   for software development, like  /Git/. Thus, when building software
   using one  of these docker  containers, development can  proceed on
   any  machine that  has Docker  installed and  when the  software is
   ready  to  be  deployed,  developers can  send  containers  to  the
   machines  they will  run on,  and all  dependencies will  come self
   contained in the Docker container.

* Go
** Why choose Go?
   Docker is written in  Google's open-source programming language Go,
   which was developed by Robert Griesemer, Rob Pike, and Ken Thompson
   in  2007  \cite{go:2009}.   Go  belongs  to  the  ALGOL  family  of
   programming languages \cite{ohearn:1996}, thus its syntax resembles
   C  in  many  ways  \cite{go-faq:2016}.   It  is  statically  typed,
   compiled,  allows for  multithreaded applications,  and includes  a
   garbage collector \cite{go-faq:2016}. Jérôme Petazzoni, a developer
   at Docker Inc., has stated several  reasons for choosing Go for the
   development  of  Docker:  (i)  static  compilation,  (ii)  language
   neutrality, (iii) language  features, (iv) development environment,
   and (v)  cross architecture compatability \cite{slideshare:2013}.

   Petazzoni  also   provides  several  drawback  to   using  Go:  (i)
   thread-safety,   (ii)   revision   issues,   (iii)   multiple-build
   difficulties, (iv)  lack of an integrated  development environment,
   and (v)  error-handling verbosity. We will  ignore (ii) Petazonni's
   recommendation  for  Go,  based  on  language  neutrality,  largely
   because we  want to examine other  options, but also because  we do
   not view language neutrality as  an expensive cost when considering
   which language is best suited for a project. Throughout the remainder
   of this paper, we will consider how Java, Python, and Rust align
   with the features, which Petazonni highlights.    

* Java
** Benefits comparison with Go
*** Static typing and development environments
   Like Go, Java is statically typed \cite[p.12]{Evans:2014}. But Java
   shares more with Go; it too  has built in support for multithreaded
   applications, as  well as  a garbage collector.   Moreover, because
   Java  has  existed  since   1996  \cite[p.7]{Evans:2014},  a  large
   repetoire of development environments, including several integrated
   development  environments,  e.g.,  Eclipse, Netbeans,  as  well  as
   leight-weight environments like  Microsoft Visual Studio. Petazzoni
   briefly mentions the  fact that Go can run code  from any C library
   using /cgo/ to call C functions \cite[s.19]{slideshare:2013}.  Java
   also     provides    similar     functionality    using     /native
   methods/\cite[p.69]{Evans:2014},   but   are  implicitly   platform
   dependent.
*** Cross-architechture compatability
   Finally,  because Java  was conceived  with the  aspirations to  be
   cross  architecture compatible,  and  because of  its Java  virtual
   machine   technology,  it   is  perhaps   the  most   widely  cross
   architecture compatible  programming language  we consider  in this
   paper. Thus,  item for  item, Java  appears to be  as good,  if not
   better than Go for the features  that the developers of Docker care
   about.

** Drawbacks comparison with Go

*** Multithreading
   Some  of the  same drawbacks  that Petazzoni  attributes to  Go are
   found in Java.  Although, Java has a well  understood memory model,
   programmers are  still largely responsible for  avoiding unintended
   variable  read   and  writes   by  mutliple  threads,   i.e.,  race
   conditions. Still,  Java does provide the  ability to automatically
   convert  functions into  thread-safe function,  through the  use of
   ~synchronized~  attribution, though  this may  significantly affect
   performance.  Go's  problem  of  building multiple  binaries  is  a
   non-issue in Java. 

*** Error handling
   We  have  already addressed  the  issue  of integrated  development
   environments in Java; there are a plethora of integrated developent
   environments for Java. Lastly, Java approaches the subject of error
   handling using  the /try-catch/ paradigm, which  is well-understood
   but can be similarly verbose.
   
     # revision issues

     # multiple-build difficulties

     # integrated development environment

     # error-handling verbositty
   
* Python   
** Benefits comparison with Go
*** Dynamic typing
   Python is  perhaps the most  different programming language  of the
   three  we consider  in  this paper.  Python is  a  very high  level
   dynamic interpreted language  \cite{python:2016}. Because Python is
   a  dynamically typed  language, we  no longer  have the  problem of
   compiling. We can write source code and immediately run our DockAlt
   program. Of course, this convenience  does not come without a cost;
   we lose  our statically compiled  safety checks before  our program
   runs.
*** Language features
   As  far  as language  features  are  concerned, Python  offers  the
   greatest number  of programming paradigms of  the three alternative
   languages   we   are   considering;  it   offers   object-oriented,
   imperative,  functional, and  procedural programming  styles. Like,
   Java and Go, it incorporates  automatic memory management through a
   garbage collector.   Thus, when we  directly compare Python  and Go
   with the features  outlined by Petazzoni, we seem to  have a better
   candidate with  Python. Moreover, it provides  interfaces to system
   calls and  libraries, which  were important  benefits of  Go, which
   were       also      touted       as      benefits       of      Go
   \cite[s.22]{slideshare:2013}. Lastly,  both Go and Python  use duck
   typing, which allows us to write code more dynamically.
*** Cross-architechture compatability
   Similar to the benefits we discussed  with Java, Python offers us a
   cornucopia of developments environments options. Lastly, because of
   its popularity and interpreter implementations, Python runs on over
   twenty  platforms, including  all  the  major platforms,  including
   Linux.

** Drawbacks comparison with Go
   One of the biggest drawbacks to Go, as stated by Petazzoni, is the
   the fact that maps are not thread-safe in Go. In this regard Python
   appears to be a better option since global dictionaries are thread
   safe in Python. In fact all builtin types are thread-safe in Python
   \cite{python_glossary:2016}. We do have an issue with software
   revision in Python, as the transition from Python 2.x to 3.x remains
   an ongoing issue in the Python community. Many libraries have
   begun the transition to 3.x, but not all libraries have completed
   the transitions.

   Petazzoni's criticism of Go's multiple binary builds is a non-issue
   for Python, since  the code is not compiled at  all. Similarly, the
   integrated development environment issue  is non-existent in Python
   as there  are more  integrated development environments  for Python
   than  Java. Finally,  Python  approaches error  handling using  the
   /try-catch/ approach favored by Java.  Thus, it too can be verbose,
   but is a well understood paradigm.
   
* Rust
** Static typing and garbage collection
  Having its  first stable release in  May 2015, Rust is  the youngest
  language  we  will  consider  in  this  paper  \cite{rust_faq:2016}.
  Petazzoni      makes      a      brief     mention      of      Rust
  \cite[s.26]{slideshare:2013}, in his explanation  for why the Docker
  team chose  Go, asserting that Go  is ``more real than  Rust.'' This
  situation may have been true in  2013, when Petazzoni gave his talk;
  however, since then  Rust has had an official  release, as explained
  above.

  Both  languages  share the  fact  that  they are  statically  typed;
  however, Rust does not use  a garbage collector, guaranteeing memory
  safety through  what Rust  developers call ownership  and borrowing.
  Thus, although we  would be responsible for  memory management, Rust
  will     not     allow     us     to     write     software     that
  /segfaults/\cite{rust_faq:2016}, i.e., crashes  because of unplanned
  memory bugs.

  Rust  is  a  young  language;  therefore,  it  lacks  an  integrated
  development  environment.   It  is  available for  the  three  major
  operating systems: Windows, OS X, and Linux. Furthermore, the source
  code  for  building  Rust  is available;  however,  even  some  Unix
  environments  do  not  currently support  Rust  out-of-the-box.  For
  example,  Rust  can  only  compile   on  FreeBSD  versions  10.x  and
  above. Nevertheless, since we want DockAlt to run on a Linux system,
  the issue is moot.

** Go drawbacks compared with Rust   
   
   Thread safety,  and Rust's approach  to concurrency in  general, is
   the  biggest reason  to  adopt  Rust over  Go.  According to  their
   documentation, `` Rust programs must be memory safe, having no data
   races'' \cite{rust_faq:2016}. Thus,  given that we can  rely on the
   compiler to enforce  memory safety, we can  develop concurrent code
   without the  fear of data races.

   Returning to  Petazzoni's criticism of Go's  revision history, Rust
   has  had significant  code-base  changes.  Similarly,  it lacks  an
   integrated  development  environment.   Finally,  documenation  for
   Rust's error handling suggests that subject is dealt with seriously
   by Rust, albeit more verbose than Go.

* Conclusion
  
  # Groups of languages
  

  # What we want
  
  # Recommendation

  # What we get in return

# Your summary should focus on the technologies' effects on ease of
# use, flexibility, generality, performance, reliability; thie idea is
# to explore the most-important technical challenges in doing the
# proposed rewrite.

\bibliographystyle{acm}
\bibliography{refs}
