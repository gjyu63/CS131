#+AUTHOR: Ryan Sharif
#+TITLE: Homework 6: Containerization support languages
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{emacs}
#+LATEX_HEADER: \usepackage{amsthm}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{mathpazo}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \linespread{1.05}
#+LaTex_HEADER: \usepackage{usenix,epsfig,endnotes}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usetikzlibrary{positioning,calc}
#+OPTIONS: toc:nil
#+LaTeX_CLASS_OPTIONS: [letterpaper,twocolumn,10pt]
#+BIBLIOGRAPHY: refs acm

# Abstract

# Linux Containers (LXC)
* Containers
** Linux containers (LXC)
   For several  decades, the model  of running software on  a computer
   consisted of a hardware layer  and an operating system layer, which
   created an environment  for running and executing  a user's machine
   code. Although the virtual machine  model traces its history to the
   early 1960s  \cite{pugh:1995}, virtualization of a  hardware system
   became popular in the late 1990s through software such as VMware.
   
   Initially  released in  2008 \cite{linuxlxc2016},  Linux containers
   (LXC) have become a popular  approach to virtualization. LXC are an
   alternative to  the virtual  machine approaches, which  emulate the
   hardware of a computer system  through software, e.g., CPU, memory,
   and hard-disks.  LXC, on the other hand, run using a system's Linux
   kernel, which isolates and manages the resources of an application,
   allowing a container full  access to CPU, memory, input-and-output,
   etc...
   
   Put simply, an  LXC is the marriage between  executing machine code
   natively and executing  machine code on a virtual  machine, you get
   the  benefits  and  isolation  of a  virtual  machine  without  the
   overhead memory and CPU costs.  In other words, a container affords
   developers  the  benefits  of  virtualization  without  a  hardware
   emulation layer. Thus, our analysis of containers will proceed with
   these core ideas.

** Docker containers
   # fix, this should include information about the recent switch
   # from LXC to runc
   # http://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-normal-virtual-machine
   According   to  their   documentation  \cite{docker:2016},   Docker
   containers  ship  a  piece  of  software  with  a  filesystem  with
   everything needed to  run code, runtimes, system  tools, and system
   libraries,  i.e., a  useable virtual  machine.  The  project is  an
   open-source approach to LXC, with the ability to track changes to a
   system in a way that is analagous to source code management systems
   for software development, like  /Git/. Thus, when building software
   using one  of these docker  containers, development can  proceed on
   any  machine that  has Docker  installed and  when the  software is
   ready  to  be  deployed,  developers can  send  containers  to  the
   machines  they will  run on,  and all  dependencies will  come self
   contained in the Docker container.

* Go
** Why choose Go?
   Docker is written in  Google's open-source programming language Go,
   which was developed by Robert Griesemer, Rob Pike, and Ken Thompson
   in  2007  \cite{go:2009}.   Go  belongs  to  the  ALGOL  family  of
   programming languages \cite{ohearn:1996}, thus its syntax resembles
   C  in  many  ways  \cite{go-faq:2016}.   It  is  statically  typed,
   compiled,  allows for  multithreaded applications,  and includes  a
   garbage collector \cite{go-faq:2016}. Jérôme Petazzoni, a developer
   at Docker Inc., has stated several  reasons for choosing Go for the
   development  of  Docker:  (i)  static  compilation,  (ii)  language
   neutrality, (iii) language  features, (iv) development environment,
   and (v)  cross architecture compatability \cite{slideshare:2013}.

   Petazzoni  also   provides  several  drawback  to   using  Go:  (i)
   thread-safety,   (ii)   revision   issues,   (iii)   multiple-build
   difficulties, (iv)  lack of an integrated  development environment,
   and (v)  error-handling verbosity. We will  ignore (ii) Petazonni's
   recommendation  for  Go,  based  on  language  neutrality,  largely
   because we  want to examine other  options, but also because  we do
   not view language neutrality as  an expensive cost when considering
   which language is best suited for a project. Throughout the remainder
   of this paper, we will consider how Java, Python, and Rust align
   with the features, which Petazonni highlights.    
  
# Java
* Java
** Benefits comparison with Go
   Like Go, Java is statically typed \cite[p.12]{Evans:2014}. But Java
   shares more with Go; it too  has built in support for multithreaded
   applications, as  well as  a garbage collector.   Moreover, because
   Java  has  existed  since   1996  \cite[p.7]{Evans:2014},  a  large
   repetoire of development environments, including several integrated
   development  environments,  e.g.,  Eclipse, Netbeans,  as  well  as
   leight-weight environments like  Microsoft Visual Studio. Petazzoni
   briefly mentions the  fact that Go can run code  from any C library
   using /cgo/ to call C functions \cite[s.19]{slideshare:2013}.  Java
   also     provides    similar     functionality    using     /native
   methods/\cite[p.69]{Evans:2014},   but   are  implicitly   platform
   dependent.

   Finally,  because Java  was conceived  with the  aspirations to  be
   cross  architecture compatible,  and  because of  its Java  virtual
   machine   technology,  it   is  perhaps   the  most   widely  cross
   architecture compatible  programming language  we consider  in this
   paper. Thus,  item for  item, Java  appears to be  as good,  if not
   better than Go for the features  that the developers of Docker care
   about.

** Drawbacks comparison with Go


# Python

# Rust

# Conclusion

# Your summary should focus on the technologies' effects on ease of
# use, flexibility, generality, performance, reliability; thie idea is
# to explore the most-important technical challenges in doing the
# proposed rewrite.

\bibliographystyle{acm}
\bibliography{refs}
