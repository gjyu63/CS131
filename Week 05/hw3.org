#+TITLE: Breaking and fixing the Java Memory Model for profit

* Introduction
** Checking environment variables and Java version
*** Java version
Before we get started doing anything else in the assignment,
let's make sure that we have our environment variables and
an appropriate version of Java. I'll be using a local copy
of JDK version 1.8.071:

#+BEGIN_SRC sh 
java -version
#+END_SRC

#+RESULTS:
Java(TM) SE Runtime Environment (build 1.8.0_71-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.71-b15, mixed mode)
*** CPU information
We can look at our CPU information using ~less~ to see that we will
be using an Inter Core i3 Processor running at 3.3GHz. My particular
machine reports a single core. This may or may not affect the way
interleaved CPU instructions are executed on several cores. Thus,
I will run my code locally and on UCLA's SEASNET servers. 

#+BEGIN_SRC sh
less /proc/cpuinfo
#+END_SRC
*** Memory Information
We can similarly inspect our machine's memory information by look at
the `/proc/meminfo' file, which tells me that I have 764300 kB of
memory total.
* Running the tests
** Extracting jmm.jar
The files that we'll need for this assignment are compressed in 
the `jmm.jar' file. Thus, we'll need to decompress the jar file
before we can do anything else:

#+BEGIN_SRC sh :result output
jar -xvf executables/jmm.jar 
#+END_SRC

#+RESULTS:
 created:   META-INF/              
 inflated:  META-INF/MANIFEST.MF   
 inflated:  NullState.java         
 inflated:  State.java             
 inflated:  SwapTest.java          
 inflated:  SynchronizedState.java 
 inflated:  UnsafeMemory.java      
** Makefile
Compiling the source files into executable class files will become tedious.
We can automate this process using a Makefile:

#+BEGIN_SRC make
JC = javac
OUTPUT = executables/

all: nullstate swaptest synchronized_state state unsafe_memory

# All classes for this assingnment
nullstate : NullState.java
	$(JC) -d $(OUTPUT) NullState.java
swaptest : SwapTest.java
	$(JC) -d $(OUTPUT) SwapTest.java
synchronized_state : SynchronizedState.java
	$(JC) -d $(OUTPUT) SynchronizedState.java
state: State.java
	$(JC) -d $(OUTPUT) State.java
unsafe_memory: UnsafeMemory.java
	$(JC) -d $(OUTPUT) UnsafeMemory.java

clean:
	rm $(OUTPUT)* 
#+END_SRC
** Testing
With the prerequisite files and environment variables all in order, we
can begin testing and working on the assignment. We'll begin our tests
on the Synchronized implementation, moving over to the Null model
afterwards.
*** Synchronized model
Here we test the synchronized model first. The initial results on my
local machine indicate that this program is not benefiting from more
threads. In fact, the more cores we add, the worse our program
performs. Given, these results, I will move over to the SEASNET
servers to test application peformance on a multicore machine.

#+BEGIN_SRC sh :result output
cd files/executables;
java UnsafeMemory Synchronized 1 1000000 6 5 6 3 0 3
java UnsafeMemory Synchronized 2 1000000 6 5 6 3 0 3
java UnsafeMemory Synchronized 4 1000000 6 5 6 3 0 3
java UnsafeMemory Synchronized 8 1000000 6 5 6 3 0 3
java UnsafeMemory Synchronized 16 1000000 6 5 6 3 0 3
java UnsafeMemory Synchronized 32 1000000 6 5 6 3 0 3
#+END_SRC

#+RESULTS:
| Threads  average | 70.7651  ns/transition |
| Threads  average | 183.874  ns/transition |
| Threads  average | 428.767  ns/transition |
| Threads  average | 843.679  ns/transition |
| Threads  average | 1842.09  ns/transition |
| Threads  average | 3631.31  ns/transition |

Below are the tests and results from running the same
application on the SEASNET servers. The results from
the SEASNET servers run approximately twice as fast
as the results my local machine produced. 

#+BEGIN_SRC sh :result output
cd files/executables;
echo -n "01: "; java UnsafeMemory Synchronized 1 1000000 6 5 6 3 0 3
echo -n "02: "; java UnsafeMemory Synchronized 2 1000000 6 5 6 3 0 3
echo -n "04: "; java UnsafeMemory Synchronized 4 1000000 6 5 6 3 0 3
echo -n "08: "; java UnsafeMemory Synchronized 8 1000000 6 5 6 3 0 3
echo -n "16: ";java UnsafeMemory Synchronized 16 1000000 6 5 6 3 0 3
echo -n "32: ";java UnsafeMemory Synchronized 32 1000000 6 5 6 3 0 3
#+END_SRC

#+RESULTS:
| 01:  Threads | average  69.6014  ns/transition |
| 02:  Threads | average  466.235  ns/transition |
| 04:  Threads | average  1472.91  ns/transition |
| 08:  Threads | average  2787.14  ns/transition |
| 16:  Threads | average  5508.66  ns/transition |
| 32:  Threads | average  13323.8  ns/transition |

*** Null model
#+BEGIN_SRC sh :result output
cd files/executables;
echo -n "01 "; java UnsafeMemory Null 1 1000000 6 5 6 3 0 3

echo -n "02 "; java UnsafeMemory Null 2 1000000 6 5 6 3 0 3
echo -n "04 "; java UnsafeMemory Null 4 1000000 6 5 6 3 0 3
echo -n "08 "; java UnsafeMemory Null 8 1000000 6 5 6 3 0 3
echo -n "16 "; java UnsafeMemory Null 16 1000000 6 5 6 3 0 3
echo -n "32 "; java UnsafeMemory Null 32 1000000 6 5 6 3 0 3
#+END_SRC

#+RESULTS:
| 1  Threads  | average  42.6443  ns/transition |
| 2  Threads  | average  97.9121  ns/transition |
| 4  Threads  | average  256.354  ns/transition |
| 8  Threads  | average  481.088  ns/transition |
| 16  Threads | average  1400.48  ns/transition |
| 32  Threads | average  1701.61  ns/transition |


